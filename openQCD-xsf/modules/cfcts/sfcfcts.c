
/*******************************************************************************
*
* File sfcfcts.c
*
* Copyright (C) 2013, 2014 Mattia Dalla Brida
*
* This software is distributed under the terms of the GNU General Public
* License (GPL)
*
* General programs for the calculation of SF correlation functions
*
* The externally accessible functions are
*
*   void sfprop(int x0,int isp,spinor_dble *sk,int *status)
*     Inverts the SF Dirac operator on the boundary source field located 
*     at the time slice x0. The variable x0 can thus only take the values
*     x0=0,NPROC0*L0-1. The solver is specified by the solver index isp, 
*     and the exit status is returned in status. The 12 components of the
*     SF propagator, one for each color and dirac index ic and id, are then
*     accessed as sk[3*(id-1)+(ic-1)]. 
*
*   void pull_slice(int x0,spinor_dble *s,spinor_dble *r)
*     Applies to the source field s at time x0 the linear transformation
*
*      r(y,x0-1) = U([y,x0-1],0)*P_-*s(y,x0)
*   
*     The result is stored in the spinor field r at the time slice x0-1. 
*     The other time slices of r instead are set equal to the ones of s.
*     Note that the spinors s and r can be the same, and x0 can only take
*     values x0>0, and x0<=NPROC0*L0-1.
*
*   void push_slice(int x0,spinor_dble *s,spinor_dble *r)
*     Applies to the source field s at time x0 the linear transformation
*
*      r(y,x0+1) = U([y,x0],0)^dag*P_+*s(y,x0)
*   
*     The result is stored in the spinor field r at the time slice x0+1. 
*     The other time slices of r instead are set equal to the ones of s.
*     Note that the spinors s and r can be the same, and x0 can only take
*     the values x0>=0, and x0<NPROC0*L0-1.
*
* Notes:
*
* All programs in this module involve global communications and must be
* called simultaneously on all processes.
*
* Before the program sfprop() is launched, the lattice, sf and solver
* parameters must be set through set_lat_parms(), set_sf_parms(),  
* set_gcr_parms() and set_sw_parms() [see parms.c]. Moreover, if nodfl=0,
* the deflation parameters must be set through set_dfl_parms() and the 
* deflation subspace must have been generated by calling dfl_subspace(),
* dfl_modes() or dfl_update() (the program checks this by querying the 
* flags data base).
*
* The program sfprop() requires a workspace of 2*nkv+2 single-precision
* spinor fields and 3+1 (only 2 if nodfl!=0) double-precision spinor fields,
* where nkv is the number of Krylov vectors set by set_gcr_parms(). The
* workspace is reserved using the utilities in the module wspace.c, which
* must therefore also be used in the calling programs.
*
*******************************************************************************/

#define SFCFCTS_C

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "mpi.h"
#include "cfcts.h"
#include "dfl.h"
#include "flags.h"
#include "lattice.h"
#include "sap.h"
#include "utils.h"
#include "uflds.h"
#include "sflds.h"
#include "su3.h"
#include "dirac.h"
#include "forces.h"
#include "linalg.h"
#include "global.h"


static void wallsrc_bnd(int x0,int id,int ic,spinor_dble *s)
{
   int ix,t;
   int iprms[3];
   spinor_dble *sm;
   su3_vector_dble *v;

   if (NPROC>1)
   {
      iprms[0]=x0;
      iprms[1]=id;
      iprms[2]=ic;
      MPI_Bcast(iprms,3,MPI_INT,0,MPI_COMM_WORLD);
      error((iprms[0]!=x0)||(iprms[1]!=id)||(iprms[2]!=ic),1,
            "wallsrc_bnd [sfcfcts.c]","Parameters are not global");   
   }
   
   error_root((id<1)||(id>4)||(ic<1)||(ic>3),1,
              "wallsrc_bnd [sfcfcts.c]","Improper argument id,ic"); 
   
   error_root((x0!=0)&&(x0!=(NPROC0*L0-1)),1,
            "wallsrc_bnd [sfcfcts.c]","Improper argument x0");
 
   sm=s+VOLUME;
   set_sd2zero(VOLUME,s);

   if ((cpr[0]==0)||(cpr[0]==(NPROC0-1)))
   {
      ix=0;
 
      for(;s<sm;s++)
      {
         t=global_time(ix);
         ix+=1;

         if (t==x0)
         {
            if (id==1) 
               v=&((*s).c1);
            else if (id==2) 
               v=&((*s).c2);
            else if (id==3) 
               v=&((*s).c3);
            else 
               v=&((*s).c4);

            if (ic==1) 
               (*v).c1.re=1.0;
            else if (ic==2)
               (*v).c2.re=1.0; 
            else 
               (*v).c3.re=1.0;
         }
      }
   }
}


static void mulPm_su3_dble(su3_dble *u,spinor_dble *s,spinor_dble *r)
{
   spinor_dble rs;
   su3_vector_dble psi;

   _vector_add(psi,(*s).c1,(*s).c3);
   _su3_multiply(rs.c1,(*u),psi);
   rs.c3=rs.c1;

   _vector_add(psi,(*s).c2,(*s).c4);
   _su3_multiply(rs.c2,(*u),psi);
   rs.c4=rs.c2;

   _vector_mul((*r).c1,0.5,rs.c1);
   _vector_mul((*r).c2,0.5,rs.c2);
   _vector_mul((*r).c3,0.5,rs.c3);
   _vector_mul((*r).c4,0.5,rs.c4);
}


static void mulPp_su3dag_dble(su3_dble *u,spinor_dble *s,spinor_dble *r)
{
   spinor_dble rs;
   su3_vector_dble psi;

   _vector_sub(psi,(*s).c1,(*s).c3);
   _su3_inverse_multiply(rs.c1,(*u),psi);
   _vector_mul(rs.c3,-1.0,rs.c1);

   _vector_sub(psi,(*s).c2,(*s).c4);
   _su3_inverse_multiply(rs.c2,(*u),psi);
   _vector_mul(rs.c4,-1.0,rs.c2);

   _vector_mul((*r).c1,0.5,rs.c1);
   _vector_mul((*r).c2,0.5,rs.c2);
   _vector_mul((*r).c3,0.5,rs.c3);
   _vector_mul((*r).c4,0.5,rs.c4);
}


void pull_slice(int x0,spinor_dble *s,spinor_dble *r)
{
   int ix,t;
   int iprms[1];
   int *piup,*pidn;
   spinor_dble *so,*ro;
   spinor_dble *sp,*rm;
   su3_dble *u,*um;

   if (NPROC>1)
   {
      iprms[0]=x0;

      MPI_Bcast(iprms,1,MPI_INT,0,MPI_COMM_WORLD);

      error(iprms[0]!=x0,1,
            "pull_slice [sfcfcts.c]","Parameters are not global");   
   }

   error_root(((x0<1)||(x0>NPROC0*L0-1)),1,
               "pull_slice [sfcfcts.c]","Improper argument x0");

   so=s+VOLUME/2;
   ro=r+VOLUME/2;
   piup=iup[VOLUME/2];
   pidn=idn[VOLUME/2];

   u=udfld();
   um=u+4*VOLUME;

   assign_sd2sd(VOLUME/2,s,r);
   ix=VOLUME/2;

   for (;u<um;u+=8)
   {
      t=global_time(ix);
      ix+=1;

      if (t==x0)
      {
         rm=r+(*pidn);
         mulPm_su3_dble(u+1,so,rm);
         (*ro)=(*so);
      }
      else if (t==(x0-1))
      {
         sp=s+(*piup);
         mulPm_su3_dble(u,sp,ro);
      }
      else
         (*ro)=(*so);

      so+=1;
      ro+=1;
      piup+=4;
      pidn+=4;
   }
}


void push_slice(int x0,spinor_dble *s,spinor_dble *r)
{
   int ix,t;
   int iprms[1];
   int *piup,*pidn;
   spinor_dble *so,*ro;
   spinor_dble *sm,*rp;
   su3_dble *u,*um;

   if (NPROC>1)
   {
      iprms[0]=x0;

      MPI_Bcast(iprms,1,MPI_INT,0,MPI_COMM_WORLD);

      error(iprms[0]!=x0,1,
            "push_slice [sfcfcts.c]","Parameters are not global");   
   }

   error_root(((x0<0)||(x0>(NPROC0*L0-2))),1,
               "push_slice [sfcfcts.c]","Improper argument x0");

   so=s+(VOLUME/2);
   ro=r+(VOLUME/2);
   piup=iup[VOLUME/2];
   pidn=idn[VOLUME/2];

   u=udfld();
   um=u+4*VOLUME;

   assign_sd2sd(VOLUME/2,s,r);
   ix=VOLUME/2;

   for (;u<um;u+=8)
   {
      t=global_time(ix);
      ix+=1;

      if (t==x0)
      {
         rp=r+(*piup);
         mulPp_su3dag_dble(u,so,rp);
         (*ro)=(*so);
      }
      else if (t==(x0+1))
      {
         sm=s+(*pidn);
         mulPp_su3dag_dble(u+1,sm,ro);
      }
      else
         (*ro)=(*so);

      so+=1;
      ro+=1;
      piup+=4;
      pidn+=4;
   }
}


void sfprop(int x0,int isp,spinor_dble **sk,int *status)
{
   int iprms[2];
   int ic,id,stat;
   solver_parms_t sp;
   sap_parms_t sap;
   spinor_dble **wsd,**psd;
   sf_parms_t sf;

   sf=sf_parms();
   error_root((sf.flg!=1),1,"sfprop [sfcfcts.c]",
              "SF boundary values are not set");
  
   if (NPROC>1)
   {
      iprms[0]=x0;
      iprms[1]=isp;

      MPI_Bcast(iprms,2,MPI_INT,0,MPI_COMM_WORLD);

      error((iprms[0]!=x0)||(iprms[1]!=isp),1,"sfprop [sfcfcts.c]",
            "Parameters are not global");   
   }
 
   error_root(((x0!=0)&&(x0!=(NPROC0*L0-1))),1,"sfprop [sfcfcts.c]",
             "Improper argument x0");

   stat=0;
   sp=solver_parms(isp);
   wsd=reserve_wsd(1);

   for (id=1;id<=2;id++)
   {
      for (ic=1;ic<=3;ic++)
      {
         psd=sk+3*(id-1)+(ic-1);
         wallsrc_bnd(x0,id,ic,wsd[0]);

         if(x0==0)
            push_slice(x0,wsd[0],wsd[0]); 
         else 
            pull_slice(x0,wsd[0],wsd[0]); 

         bnd_sd2zero(ALL_PTS,wsd[0]);

         if (sp.solver==CGNE)
         {
            mulg5_dble(VOLUME,wsd[0]);
            tmcg(sp.nmx,sp.res,0.0,wsd[0],wsd[0],&stat);
            Dw_dble(0.0,wsd[0],(*psd));
            mulg5_dble(VOLUME,(*psd));
         }
         else if (sp.solver==SAP_GCR)
         {
            sap=sap_parms();
            set_sap_parms(sap.bs,sp.isolv,sp.nmr,sp.ncy);
            sap_gcr(sp.nkv,sp.nmx,sp.res,0.0,wsd[0],(*psd),&stat);
         }
         else if (sp.solver==DFL_SAP_GCR)
         {
            sap=sap_parms();
            set_sap_parms(sap.bs,sp.isolv,sp.nmr,sp.ncy);
            dfl_sap_gcr(sp.nkv,sp.nmx,sp.res,0.0,wsd[0],(*psd),&stat);
         }
         else
            error_root(1,1,"sfprop [sfcfcts.c]","Unknown solver");

         assign_sd2sd(VOLUME,psd[0],psd[6]); 

         if (x0==0)
            scale_dble(VOLUME,-1.0,psd[6]);

         stat+=stat/6;         
      }
   }

   status[0]=stat;
   release_wsd();
}

